<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>YggSimLib API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>YggSimLib</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="YggSimLib.Admin"><code class="flex name class">
<span>class <span class="ident">Admin</span></span>
<span>(</span><span>name, sequences, edges, sim)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Admin:

    &#34;&#34;&#34;
    Administrative controller for managing and executing multiple sequences with dependency resolution.

    Args:
        name (str): Name of the admin controller.
        sequences (list of Sequence): List of sequence objects.
        edges (list of tuples): Directed edges defining execution order between sequences.
        sim (YggLCS): Reference to the simulator object.
    &#34;&#34;&#34;

    def __init__(self, name, sequences, edges, sim):
        self.name = name
        self.seq = {}
        for s in sequences:
            self.seq[s.name] = s
        # Initialise first step (START)
        dummy = {}
        dummy[&#34;start&#34;] = Step({
            &#34;number&#34;: 1,
            &#34;conditions&#34;: [],
            &#34;actions&#34;: [],
            &#34;transitions&#34;: [],
            &#34;tmax&#34;: 2,
            &#34;next&#34;: None
        })
        start_seq = Sequence(&#34;START&#34;, 
               dummy,
               sim,
               []
               )
        start_seq.add_step(dummy[&#34;start&#34;])
        self.seq[&#34;START&#34;] = start_seq

        #Initialize the last step (END)
        end = Sequence(&#34;END&#34;, 
               dummy,
               sim,
               []
               )
        end.add_step(dummy[&#34;start&#34;])
        self.seq[&#34;END&#34;] = end
        
        self.edges = edges

        # Create a directed graph
        self.G = nx.DiGraph()
        # Create the nodes and connect the edges
        self.G.add_edges_from(edges)


    def start(self):
        &#34;&#34;&#34;
        Starts the admin sequence execution
        &#34;&#34;&#34;
        self.execute_tasks(self.G, self.seq)



    def start_sequence(self, seq, name):
        &#34;&#34;&#34;
        Helper function to start a sequence and return the name of the sequence that was started.
        &#34;&#34;&#34;
        seq.start()
        return name





# Execute the tasks based on the dependency graph
    def execute_tasks(self, graph, seq_objects):
        &#34;&#34;&#34;
        Function that starts all the sequences which has no parent or whos parent has completed. 
        Parallel sequences are started in separate pseudo threads to enable paralell execution. 
        Edges in directed graph dicated when a sequence can be started.
        &#34;&#34;&#34;
        # Find the start tasks (those that have no predecessors)
        initial_tasks = [n for n in graph.nodes if graph.in_degree(n) == 0]
    
        # Initialize an executor for parallel task execution
        with ThreadPoolExecutor() as executor:
            # Track futures
            task_futures = {}
    
            # Start initial tasks
            for task_name in initial_tasks:
                
                task_futures[task_name] = executor.submit(self.start_sequence, seq_objects[task_name], task_name)
    
            # As each task finishes, check if we can start dependent tasks
            while task_futures:
                for future in as_completed(task_futures.values()):
                    task_name = future.result()  # Get the result (task name)
                    
                    if task_name is None:
                        raise ValueError(&#34;Error: Task returned None!&#34;)
    
                    # Check if task has successors
                    if task_name in graph:
                        successors = list(graph.successors(task_name))
                        for successor in successors:
                            # Check if all predecessors of the successor have finished
                            predecessors = list(graph.predecessors(successor))
                            if all(p in task_futures and task_futures[p].done() for p in predecessors):
                                # Start successor task
                                
                                task_futures[successor] = executor.submit(self.start_sequence, seq_objects[successor], successor)
    
                    # Remove completed task from tracking
                    if task_name in task_futures:
                        del task_futures[task_name]</code></pre>
</details>
<div class="desc"><p>Administrative controller for managing and executing multiple sequences with dependency resolution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the admin controller.</dd>
<dt><strong><code>sequences</code></strong> :&ensp;<code>list</code> of <code><a title="YggSimLib.Sequence" href="#YggSimLib.Sequence">Sequence</a></code></dt>
<dd>List of sequence objects.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>Directed edges defining execution order between sequences.</dd>
<dt><strong><code>sim</code></strong> :&ensp;<code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></dt>
<dd>Reference to the simulator object.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Admin.execute_tasks"><code class="name flex">
<span>def <span class="ident">execute_tasks</span></span>(<span>self, graph, seq_objects)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_tasks(self, graph, seq_objects):
    &#34;&#34;&#34;
    Function that starts all the sequences which has no parent or whos parent has completed. 
    Parallel sequences are started in separate pseudo threads to enable paralell execution. 
    Edges in directed graph dicated when a sequence can be started.
    &#34;&#34;&#34;
    # Find the start tasks (those that have no predecessors)
    initial_tasks = [n for n in graph.nodes if graph.in_degree(n) == 0]

    # Initialize an executor for parallel task execution
    with ThreadPoolExecutor() as executor:
        # Track futures
        task_futures = {}

        # Start initial tasks
        for task_name in initial_tasks:
            
            task_futures[task_name] = executor.submit(self.start_sequence, seq_objects[task_name], task_name)

        # As each task finishes, check if we can start dependent tasks
        while task_futures:
            for future in as_completed(task_futures.values()):
                task_name = future.result()  # Get the result (task name)
                
                if task_name is None:
                    raise ValueError(&#34;Error: Task returned None!&#34;)

                # Check if task has successors
                if task_name in graph:
                    successors = list(graph.successors(task_name))
                    for successor in successors:
                        # Check if all predecessors of the successor have finished
                        predecessors = list(graph.predecessors(successor))
                        if all(p in task_futures and task_futures[p].done() for p in predecessors):
                            # Start successor task
                            
                            task_futures[successor] = executor.submit(self.start_sequence, seq_objects[successor], successor)

                # Remove completed task from tracking
                if task_name in task_futures:
                    del task_futures[task_name]</code></pre>
</details>
<div class="desc"><p>Function that starts all the sequences which has no parent or whos parent has completed.
Parallel sequences are started in separate pseudo threads to enable paralell execution.
Edges in directed graph dicated when a sequence can be started.</p></div>
</dd>
<dt id="YggSimLib.Admin.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Starts the admin sequence execution
    &#34;&#34;&#34;
    self.execute_tasks(self.G, self.seq)</code></pre>
</details>
<div class="desc"><p>Starts the admin sequence execution</p></div>
</dd>
<dt id="YggSimLib.Admin.start_sequence"><code class="name flex">
<span>def <span class="ident">start_sequence</span></span>(<span>self, seq, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_sequence(self, seq, name):
    &#34;&#34;&#34;
    Helper function to start a sequence and return the name of the sequence that was started.
    &#34;&#34;&#34;
    seq.start()
    return name</code></pre>
</details>
<div class="desc"><p>Helper function to start a sequence and return the name of the sequence that was started.</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Choke"><code class="flex name class">
<span>class <span class="ident">Choke</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Choke:
    &#34;&#34;&#34;
    Wrapper for operating choke and control valves in the Yggdrasil Engineering Simulator.

    Args:
        tag (str): Tag name of the choke valve.
        model (YggLCS): Reference to the YggLCS simulation object.
        app (str, optional): Application name. Automatically inferred if not provided.
    &#34;&#34;&#34;
    def __init__(self, tag, model, app=False):  



        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.c = self.tl.get_block(app, tag)
            except:
                print(&#34;No choke with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No choke with tag {} found in any of the simulator applications&#34;.format(tag))
            self.c = False

        if self.c:
            if self.c.type not in [&#34;ControlValve&#34;, &#34;LedaValve&#34;]:
                print(&#34;Object is not a Control Valve. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.c.type))
                self.c = False

    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False       
    
    def move_to(self, pos):
        &#34;&#34;&#34;
        Wrapper that moves a choke object to a desired position.  
        If LocalControlSignalIn is connected from an external source, the choke will be set in Manual Mode
        &#34;&#34;&#34;
        connections = self.tl.get_block(self.app, self.c.name).input_connections
        if len(connections) &gt; 0:
            for conn in connections:
                if &#34;LocalControlSignalIn&#34; in str(conn):
                    self.direct_control()
        self.tl.set_value(self.app, self.c.name + &#34;:LocalControlSignalIn&#34;, pos, unit=&#34;%&#34;)
        self.tl.set_value(self.app, self.c.name + &#34;:TargetPosition&#34;, pos, unit=&#34;%&#34;)

    def direct_control(self):
        &#34;&#34;&#34;
        Set object in manual mode
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:InputSwitch&#34;,2)

    def reset_control(self):
        &#34;&#34;&#34;
        If object has defined connection to LocalControlSignalIn, set mode to Local
        &#34;&#34;&#34;
        connections = self.tl.get_block(self.app, self.c.name).input_connections
        if len(connections) &gt; 0:
            for conn in connections:
                if &#34;LocalControlSignalIn&#34; in str(conn):
                    self.tl.set_value(self.app, self.c.name + &#34;:InputSwitch&#34;, 0)      
    
    def get_pos(self):
        return self.tl.get_value(self.app, self.c.name + &#34;:ValveStemPosition&#34;, unit=&#34;%&#34;)</code></pre>
</details>
<div class="desc"><p>Wrapper for operating choke and control valves in the Yggdrasil Engineering Simulator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code></dt>
<dd>Tag name of the choke valve.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></dt>
<dd>Reference to the YggLCS simulation object.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Application name. Automatically inferred if not provided.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Choke.direct_control"><code class="name flex">
<span>def <span class="ident">direct_control</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def direct_control(self):
    &#34;&#34;&#34;
    Set object in manual mode
    &#34;&#34;&#34;
    self.tl.set_value(self.app, self.c.name + &#34;:InputSwitch&#34;,2)</code></pre>
</details>
<div class="desc"><p>Set object in manual mode</p></div>
</dd>
<dt id="YggSimLib.Choke.get_pos"><code class="name flex">
<span>def <span class="ident">get_pos</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pos(self):
    return self.tl.get_value(self.app, self.c.name + &#34;:ValveStemPosition&#34;, unit=&#34;%&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.Choke.move_to"><code class="name flex">
<span>def <span class="ident">move_to</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to(self, pos):
    &#34;&#34;&#34;
    Wrapper that moves a choke object to a desired position.  
    If LocalControlSignalIn is connected from an external source, the choke will be set in Manual Mode
    &#34;&#34;&#34;
    connections = self.tl.get_block(self.app, self.c.name).input_connections
    if len(connections) &gt; 0:
        for conn in connections:
            if &#34;LocalControlSignalIn&#34; in str(conn):
                self.direct_control()
    self.tl.set_value(self.app, self.c.name + &#34;:LocalControlSignalIn&#34;, pos, unit=&#34;%&#34;)
    self.tl.set_value(self.app, self.c.name + &#34;:TargetPosition&#34;, pos, unit=&#34;%&#34;)</code></pre>
</details>
<div class="desc"><p>Wrapper that moves a choke object to a desired position.<br>
If LocalControlSignalIn is connected from an external source, the choke will be set in Manual Mode</p></div>
</dd>
<dt id="YggSimLib.Choke.reset_control"><code class="name flex">
<span>def <span class="ident">reset_control</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_control(self):
    &#34;&#34;&#34;
    If object has defined connection to LocalControlSignalIn, set mode to Local
    &#34;&#34;&#34;
    connections = self.tl.get_block(self.app, self.c.name).input_connections
    if len(connections) &gt; 0:
        for conn in connections:
            if &#34;LocalControlSignalIn&#34; in str(conn):
                self.tl.set_value(self.app, self.c.name + &#34;:InputSwitch&#34;, 0)      </code></pre>
</details>
<div class="desc"><p>If object has defined connection to LocalControlSignalIn, set mode to Local</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Motor_Heater"><code class="flex name class">
<span>class <span class="ident">Motor_Heater</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Motor_Heater:
    &#34;&#34;&#34;
    Wrapper for operating motors and electric heaters in the Yggdrasil Engineering Simulator.

    Args:
        tag (str): Tag name of the motor or heater.
        model (YggLCS): Reference to the YggLCS simulation object.
        app (str, optional): Application name. Automatically inferred if not provided.
    &#34;&#34;&#34;

    def __init__(self, tag, model, app=False):  

        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.m = self.tl.get_block(app, tag)
            except:
                print(&#34;No motor with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No motor with tag {} found in any of the simulator applications&#34;.format(tag))
            self.m = False

        if self.m:
            if self.m.type not in [&#34;ControlledAsynchronousMachine&#34;, &#34;ControlledElectricHeater&#34;]:
                print(&#34;Object is not a Motor or Heater. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.m.type))
                self.m = False

    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False       
    
    def start(self):
        
        &#34;&#34;&#34; Switch on the motor/element &#34;&#34;&#34;
        if self.m:
            if self.tl.get_value(self.app, self.m.name + &#34;:OnOffOption&#34;) == 0:
                self.tl.set_value(self.app, self.m.name + &#34;:LocalInput&#34;, True)
            else:
                self.tl.set_value(self.app, self.m.name + &#34;:LocalSetOn&#34;, True)
        else:
            print(&#34;Unvaild heater or motor object&#34;)   
    def stop(self):
        
        &#34;&#34;&#34; Switch off the motor/element &#34;&#34;&#34;
        if self.m:
            if self.tl.get_value(self.app, self.m.name + &#34;:OnOffOption&#34;) == 0:
                self.tl.set_value(self.app, self.m.name + &#34;:LocalInput&#34;, False)
            else:
                self.tl.set_value(self.app, self.m.name + &#34;:LocalSetOff&#34;, True)
        else:
            print(&#34;Unvaild heater or motor object&#34;)
    def is_on(self):
        &#34;&#34;&#34; Returns True if motor/element is switched on &#34;&#34;&#34;
        if self.m.type == &#34;ControlledAsynchronousMachine&#34;:
            return self.tl.get_value(self.app, self.m.name + &#34;:MachineState&#34;) == 1
        else:
            return self.tl.get_value(self.app, self.m.name + &#34;:Running&#34;) == True
    def is_off(self):
        &#34;&#34;&#34; Returns True if motor/element is switched off &#34;&#34;&#34;
        if self.m.type == &#34;ControlledAsynchronousMachine&#34;:
            return self.tl.get_value(self.app, self.m.name + &#34;:MachineState&#34;) == 0
        return self.tl.get_value(self.app, self.m.name + &#34;:Running&#34;) == False</code></pre>
</details>
<div class="desc"><p>Wrapper for operating motors and electric heaters in the Yggdrasil Engineering Simulator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code></dt>
<dd>Tag name of the motor or heater.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></dt>
<dd>Reference to the YggLCS simulation object.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Application name. Automatically inferred if not provided.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Motor_Heater.is_off"><code class="name flex">
<span>def <span class="ident">is_off</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_off(self):
    &#34;&#34;&#34; Returns True if motor/element is switched off &#34;&#34;&#34;
    if self.m.type == &#34;ControlledAsynchronousMachine&#34;:
        return self.tl.get_value(self.app, self.m.name + &#34;:MachineState&#34;) == 0
    return self.tl.get_value(self.app, self.m.name + &#34;:Running&#34;) == False</code></pre>
</details>
<div class="desc"><p>Returns True if motor/element is switched off</p></div>
</dd>
<dt id="YggSimLib.Motor_Heater.is_on"><code class="name flex">
<span>def <span class="ident">is_on</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_on(self):
    &#34;&#34;&#34; Returns True if motor/element is switched on &#34;&#34;&#34;
    if self.m.type == &#34;ControlledAsynchronousMachine&#34;:
        return self.tl.get_value(self.app, self.m.name + &#34;:MachineState&#34;) == 1
    else:
        return self.tl.get_value(self.app, self.m.name + &#34;:Running&#34;) == True</code></pre>
</details>
<div class="desc"><p>Returns True if motor/element is switched on</p></div>
</dd>
<dt id="YggSimLib.Motor_Heater.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    
    &#34;&#34;&#34; Switch on the motor/element &#34;&#34;&#34;
    if self.m:
        if self.tl.get_value(self.app, self.m.name + &#34;:OnOffOption&#34;) == 0:
            self.tl.set_value(self.app, self.m.name + &#34;:LocalInput&#34;, True)
        else:
            self.tl.set_value(self.app, self.m.name + &#34;:LocalSetOn&#34;, True)
    else:
        print(&#34;Unvaild heater or motor object&#34;)   </code></pre>
</details>
<div class="desc"><p>Switch on the motor/element</p></div>
</dd>
<dt id="YggSimLib.Motor_Heater.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    
    &#34;&#34;&#34; Switch off the motor/element &#34;&#34;&#34;
    if self.m:
        if self.tl.get_value(self.app, self.m.name + &#34;:OnOffOption&#34;) == 0:
            self.tl.set_value(self.app, self.m.name + &#34;:LocalInput&#34;, False)
        else:
            self.tl.set_value(self.app, self.m.name + &#34;:LocalSetOff&#34;, True)
    else:
        print(&#34;Unvaild heater or motor object&#34;)</code></pre>
</details>
<div class="desc"><p>Switch off the motor/element</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.On_Off_Valve"><code class="flex name class">
<span>class <span class="ident">On_Off_Valve</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class On_Off_Valve:
    &#34;&#34;&#34;
    Wrapper for operating block-valves and motor-operated-valves in the Yggdrasil Engineering Simulator.

    Args:
        tag (str): Tag name of the valve.
        model (YggLCS): Reference to the YggLCS simulation object.
        app (str, optional): Application name. Automatically inferred if not provided.
    &#34;&#34;&#34;    
    def __init__(self, tag, model, app=False):  
        self.sim = model.sim
        self.tl = model.timeline
        self.tag = tag
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.v = self.tl.get_block(app, tag)
            except:
                print(&#34;No valve with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No valve with tag {} found in any of the simulator applications&#34;.format(tag))
            self.v = False

        if self.v:
            if self.v.type not in [&#34;MotorOperatedValve&#34;, &#34;BlockValve&#34;, &#34;LedaValve&#34;, &#34;PulseControlledValve&#34;, &#34;ControlValve&#34;]:
                print(&#34;Object is not a Leda-Valve, Motor-Operated_Valve, PulseControlledValve, ControlValve or Block-Valve. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.v.type))
                self.v = False
    
    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False    
    
    def get_valve(self):
        &#34;&#34;&#34; Return the BlockValve object &#34;&#34;&#34;
        return self.v
    

    def close(self):    
        &#34;&#34;&#34; Wrapper that closes the valve regardless of type &#34;&#34;&#34;
        if self.v:
            if self.v.type == &#34;MotorOperatedValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalClose&#34;, True)
            elif self.v.type == &#34;BlockValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalInput&#34;, False)
            elif self.v.type in [&#34;LedaValve&#34;, &#34;ControlValve&#34;]:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalControlSignalIn&#34;, 0, unit=&#34;%&#34;)
                # get and operate keyswitch if exists
                try:
                    ks = self.tl.get_block(self.app, self.tag + &#34;_KS&#34;)
                    self.tl.set_value(self.app, self.tag + &#34;_KS:RequestedPosition&#34;, False)
                except:
                    pass
                
            
                
            elif self.v.type == &#34;PulseControlledValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalSetClosed&#34;, True)
        else:
            print(&#34;Unvaild valve object&#34;)

    def open(self):
        &#34;&#34;&#34; Wrapper that open the valve regardless of type &#34;&#34;&#34;
        if self.v:
            if self.v.type == &#34;MotorOperatedValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalOpen&#34;, True)
            elif self.v.type == &#34;BlockValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalInput&#34;, True)
            elif self.v.type in [&#34;LedaValve&#34;, &#34;ControlValve&#34;]:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalControlSignalIn&#34;, 100, unit=&#34;%&#34;)
                # get and operate keyswitch if exists
                try:
                    ks = self.tl.get_block(self.app, self.tag + &#34;_KS&#34;)
                    self.tl.set_value(self.app, self.tag + &#34;_KS:RequestedPosition&#34;, True)
                except:
                    pass
            elif self.v.type == &#34;PulseControlledValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalSetOpen&#34;, True)
        else:
            print(&#34;Unvaild valve object&#34;)
            
    def get_pos(self):
        &#34;&#34;&#34; Wrapper that returns the stem position of the valve in percentage &#34;&#34;&#34;
        if self.v:
            return self.tl.get_value(self.app, self.v.name + &#34;:ValveStemPosition&#34;, unit=&#34;%&#34;)
        else:
            print(&#34;Unvaild valve object&#34;)
            
    def is_open(self):
        &#34;&#34;&#34; Wrapper that returns True if valve is defined as open &#34;&#34;&#34;
        if self.v:
            return self.tl.get_value(self.app, self.v.name + &#34;:IsDefinedOpen&#34;)
        else:
            print(&#34;Unvaild valve object&#34;)
            
    def is_closed(self):
        &#34;&#34;&#34; Wrapper that returns True if valve is defined as closed &#34;&#34;&#34;
        if self.v:
            return self.tl.get_value(self.app, self.v.name + &#34;:IsDefinedClosed&#34;)
        else:
            print(&#34;Unvaild valve object&#34;)        </code></pre>
</details>
<div class="desc"><p>Wrapper for operating block-valves and motor-operated-valves in the Yggdrasil Engineering Simulator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code></dt>
<dd>Tag name of the valve.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></dt>
<dd>Reference to the YggLCS simulation object.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Application name. Automatically inferred if not provided.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.On_Off_Valve.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):    
    &#34;&#34;&#34; Wrapper that closes the valve regardless of type &#34;&#34;&#34;
    if self.v:
        if self.v.type == &#34;MotorOperatedValve&#34;:
            self.tl.set_value(self.app, self.v.name + &#34;:LocalClose&#34;, True)
        elif self.v.type == &#34;BlockValve&#34;:
            self.tl.set_value(self.app, self.v.name + &#34;:LocalInput&#34;, False)
        elif self.v.type in [&#34;LedaValve&#34;, &#34;ControlValve&#34;]:
            self.tl.set_value(self.app, self.v.name + &#34;:LocalControlSignalIn&#34;, 0, unit=&#34;%&#34;)
            # get and operate keyswitch if exists
            try:
                ks = self.tl.get_block(self.app, self.tag + &#34;_KS&#34;)
                self.tl.set_value(self.app, self.tag + &#34;_KS:RequestedPosition&#34;, False)
            except:
                pass
            
        
            
        elif self.v.type == &#34;PulseControlledValve&#34;:
            self.tl.set_value(self.app, self.v.name + &#34;:LocalSetClosed&#34;, True)
    else:
        print(&#34;Unvaild valve object&#34;)</code></pre>
</details>
<div class="desc"><p>Wrapper that closes the valve regardless of type</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.get_pos"><code class="name flex">
<span>def <span class="ident">get_pos</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pos(self):
    &#34;&#34;&#34; Wrapper that returns the stem position of the valve in percentage &#34;&#34;&#34;
    if self.v:
        return self.tl.get_value(self.app, self.v.name + &#34;:ValveStemPosition&#34;, unit=&#34;%&#34;)
    else:
        print(&#34;Unvaild valve object&#34;)</code></pre>
</details>
<div class="desc"><p>Wrapper that returns the stem position of the valve in percentage</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.get_valve"><code class="name flex">
<span>def <span class="ident">get_valve</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valve(self):
    &#34;&#34;&#34; Return the BlockValve object &#34;&#34;&#34;
    return self.v</code></pre>
</details>
<div class="desc"><p>Return the BlockValve object</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_closed(self):
    &#34;&#34;&#34; Wrapper that returns True if valve is defined as closed &#34;&#34;&#34;
    if self.v:
        return self.tl.get_value(self.app, self.v.name + &#34;:IsDefinedClosed&#34;)
    else:
        print(&#34;Unvaild valve object&#34;)        </code></pre>
</details>
<div class="desc"><p>Wrapper that returns True if valve is defined as closed</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.is_open"><code class="name flex">
<span>def <span class="ident">is_open</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_open(self):
    &#34;&#34;&#34; Wrapper that returns True if valve is defined as open &#34;&#34;&#34;
    if self.v:
        return self.tl.get_value(self.app, self.v.name + &#34;:IsDefinedOpen&#34;)
    else:
        print(&#34;Unvaild valve object&#34;)</code></pre>
</details>
<div class="desc"><p>Wrapper that returns True if valve is defined as open</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self):
    &#34;&#34;&#34; Wrapper that open the valve regardless of type &#34;&#34;&#34;
    if self.v:
        if self.v.type == &#34;MotorOperatedValve&#34;:
            self.tl.set_value(self.app, self.v.name + &#34;:LocalOpen&#34;, True)
        elif self.v.type == &#34;BlockValve&#34;:
            self.tl.set_value(self.app, self.v.name + &#34;:LocalInput&#34;, True)
        elif self.v.type in [&#34;LedaValve&#34;, &#34;ControlValve&#34;]:
            self.tl.set_value(self.app, self.v.name + &#34;:LocalControlSignalIn&#34;, 100, unit=&#34;%&#34;)
            # get and operate keyswitch if exists
            try:
                ks = self.tl.get_block(self.app, self.tag + &#34;_KS&#34;)
                self.tl.set_value(self.app, self.tag + &#34;_KS:RequestedPosition&#34;, True)
            except:
                pass
        elif self.v.type == &#34;PulseControlledValve&#34;:
            self.tl.set_value(self.app, self.v.name + &#34;:LocalSetOpen&#34;, True)
    else:
        print(&#34;Unvaild valve object&#34;)</code></pre>
</details>
<div class="desc"><p>Wrapper that open the valve regardless of type</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.PID"><code class="flex name class">
<span>class <span class="ident">PID</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PID:
    &#34;&#34;&#34;
    Wrapper for operating PID controllers in the Yggdrasil Engineering Simulator.

    Args:
        tag (str): Tag name of the PID controller.
        model (YggLCS): Reference to the YggLCS simulation object.
        app (str, optional): Application name. Automatically inferred if not provided.
    &#34;&#34;&#34;
    def __init__(self, tag, model, app=False):  



        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.c = self.tl.get_block(app, tag)
            except:
                print(&#34;No PID controller with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No PID controller with tag {} found in any of the simulator applications&#34;.format(tag))
            self.c = False

        if self.c:
            if self.c.type not in [&#34;PidController&#34;]:
                print(&#34;Object is not a PID Controller. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.v.type))
                self.c = False

    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False   
    
    def get_mode(self):
        &#34;&#34;&#34;
        Returns text representation of the current mode
        &#34;&#34;&#34;
        m = self.tl.get_value(self.app, self.c.name + &#34;:Mode&#34;)
        if m == 0:
            return (&#34;Auto&#34;)
        elif m == 1:
            return (&#34;Manual&#34;)
        else: 
            return(&#34;External&#34;)
    
    def get_sp_selection(self):
        s = self.tl.get_value(self.app, self.c.name + &#34;:SetpointSelection&#34;)
        if s == 0:
            return(&#34;Internal&#34;)
        else:
            return(&#34;External&#34;)

    def to_auto(self):
        &#34;&#34;&#34;
        Set controller mode to Auto
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 0)

    def to_man(self):
        &#34;&#34;&#34;
        Set controller mode to Manual
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 1)

    def to_external(self):
        &#34;&#34;&#34;
        Set controller mode to External SP
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 2) 

    def set_tracking(self, state):
        &#34;&#34;&#34;
        Set tracking mode on or off
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:Tracking&#34;, state)

    def get_tracking(self):
        &#34;&#34;&#34;
        Get state of tracking
        &#34;&#34;&#34;
        return self.tl.get_value(self.app, self.c.name + &#34;:Tracking&#34;)

    def set_tracking_value(self, value):
        &#34;&#34;&#34; 
        Set the output used when tracking
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:Feedback&#34;, value)

    def set_output(self, out):
        &#34;&#34;&#34;
        Change output of controller if controller is in manual mode
        &#34;&#34;&#34;
        if self.get_mode() == &#34;Manual&#34;:
            self.tl.set_value(self.app, self.c.name + &#34;:ControllerOutput&#34;, out)
    def get_output(self):
        &#34;&#34;&#34;
        Get output of controller
        &#34;&#34;&#34;        
        return self.tl.get_value(self.app, self.c.name + &#34;:ControllerOutput&#34;)

    def set_setpoint(self, sp):
        &#34;&#34;&#34;
        Change internal setpoint of controller if controller is in manual or auto with internal setpoint selection
        &#34;&#34;&#34;
        if self.get_mode() == &#34;Manual&#34; or (self.get_mode() == &#34;Auto&#34; and self.get_sp_selection() == &#34;Internal&#34;):
            self.tl.set_value(self.app, self.c.name + &#34;:InternalSetpoint&#34;, sp)</code></pre>
</details>
<div class="desc"><p>Wrapper for operating PID controllers in the Yggdrasil Engineering Simulator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code></dt>
<dd>Tag name of the PID controller.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></dt>
<dd>Reference to the YggLCS simulation object.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Application name. Automatically inferred if not provided.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.PID.get_mode"><code class="name flex">
<span>def <span class="ident">get_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mode(self):
    &#34;&#34;&#34;
    Returns text representation of the current mode
    &#34;&#34;&#34;
    m = self.tl.get_value(self.app, self.c.name + &#34;:Mode&#34;)
    if m == 0:
        return (&#34;Auto&#34;)
    elif m == 1:
        return (&#34;Manual&#34;)
    else: 
        return(&#34;External&#34;)</code></pre>
</details>
<div class="desc"><p>Returns text representation of the current mode</p></div>
</dd>
<dt id="YggSimLib.PID.get_output"><code class="name flex">
<span>def <span class="ident">get_output</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output(self):
    &#34;&#34;&#34;
    Get output of controller
    &#34;&#34;&#34;        
    return self.tl.get_value(self.app, self.c.name + &#34;:ControllerOutput&#34;)</code></pre>
</details>
<div class="desc"><p>Get output of controller</p></div>
</dd>
<dt id="YggSimLib.PID.get_sp_selection"><code class="name flex">
<span>def <span class="ident">get_sp_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sp_selection(self):
    s = self.tl.get_value(self.app, self.c.name + &#34;:SetpointSelection&#34;)
    if s == 0:
        return(&#34;Internal&#34;)
    else:
        return(&#34;External&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.PID.get_tracking"><code class="name flex">
<span>def <span class="ident">get_tracking</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tracking(self):
    &#34;&#34;&#34;
    Get state of tracking
    &#34;&#34;&#34;
    return self.tl.get_value(self.app, self.c.name + &#34;:Tracking&#34;)</code></pre>
</details>
<div class="desc"><p>Get state of tracking</p></div>
</dd>
<dt id="YggSimLib.PID.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, out)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output(self, out):
    &#34;&#34;&#34;
    Change output of controller if controller is in manual mode
    &#34;&#34;&#34;
    if self.get_mode() == &#34;Manual&#34;:
        self.tl.set_value(self.app, self.c.name + &#34;:ControllerOutput&#34;, out)</code></pre>
</details>
<div class="desc"><p>Change output of controller if controller is in manual mode</p></div>
</dd>
<dt id="YggSimLib.PID.set_setpoint"><code class="name flex">
<span>def <span class="ident">set_setpoint</span></span>(<span>self, sp)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_setpoint(self, sp):
    &#34;&#34;&#34;
    Change internal setpoint of controller if controller is in manual or auto with internal setpoint selection
    &#34;&#34;&#34;
    if self.get_mode() == &#34;Manual&#34; or (self.get_mode() == &#34;Auto&#34; and self.get_sp_selection() == &#34;Internal&#34;):
        self.tl.set_value(self.app, self.c.name + &#34;:InternalSetpoint&#34;, sp)</code></pre>
</details>
<div class="desc"><p>Change internal setpoint of controller if controller is in manual or auto with internal setpoint selection</p></div>
</dd>
<dt id="YggSimLib.PID.set_tracking"><code class="name flex">
<span>def <span class="ident">set_tracking</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tracking(self, state):
    &#34;&#34;&#34;
    Set tracking mode on or off
    &#34;&#34;&#34;
    self.tl.set_value(self.app, self.c.name + &#34;:Tracking&#34;, state)</code></pre>
</details>
<div class="desc"><p>Set tracking mode on or off</p></div>
</dd>
<dt id="YggSimLib.PID.set_tracking_value"><code class="name flex">
<span>def <span class="ident">set_tracking_value</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tracking_value(self, value):
    &#34;&#34;&#34; 
    Set the output used when tracking
    &#34;&#34;&#34;
    self.tl.set_value(self.app, self.c.name + &#34;:Feedback&#34;, value)</code></pre>
</details>
<div class="desc"><p>Set the output used when tracking</p></div>
</dd>
<dt id="YggSimLib.PID.to_auto"><code class="name flex">
<span>def <span class="ident">to_auto</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_auto(self):
    &#34;&#34;&#34;
    Set controller mode to Auto
    &#34;&#34;&#34;
    self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 0)</code></pre>
</details>
<div class="desc"><p>Set controller mode to Auto</p></div>
</dd>
<dt id="YggSimLib.PID.to_external"><code class="name flex">
<span>def <span class="ident">to_external</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_external(self):
    &#34;&#34;&#34;
    Set controller mode to External SP
    &#34;&#34;&#34;
    self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 2) </code></pre>
</details>
<div class="desc"><p>Set controller mode to External SP</p></div>
</dd>
<dt id="YggSimLib.PID.to_man"><code class="name flex">
<span>def <span class="ident">to_man</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_man(self):
    &#34;&#34;&#34;
    Set controller mode to Manual
    &#34;&#34;&#34;
    self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 1)</code></pre>
</details>
<div class="desc"><p>Set controller mode to Manual</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Sequence"><code class="flex name class">
<span>class <span class="ident">Sequence</span></span>
<span>(</span><span>name, seqs, sim, inhibit_conditions=[], verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sequence:
    &#34;&#34;&#34;
    A sequence of steps to be executed in order, with optional inhibit conditions.

    Args:
        name (str): Name of the sequence.
        seqs (dict): Dictionary of all step objects (name  Step).
        sim (YggLCS): Reference to the simulator object.
        inhibit_conditions (list of callables, optional): Conditions that must evaluate False for the sequence to run.
        verbose (bool, optional): If True, prints execution info.
    &#34;&#34;&#34;

    def __init__(self, name, seqs, sim, inhibit_conditions=[], verbose = False):
        self.seqs = seqs
        self.steps = []
        self.inhibits = inhibit_conditions
        self.name = name
        self.sim = sim
        self.verbose = verbose

    def check_inhibits(self):
        &#34;&#34;&#34; Inhibit conditions must all evaluate to False to allow sequence to start&#34;&#34;&#34;
        ret = True
        if len(self.inhibits) &gt; 0:            
            for inhibit in self.inhibits:
                if inhibit():
                    print(&#34;Inhibit condition prevents sequence start of &#34; + self.name + &#34;: &#34; + str(inhibit))
                    ret = False
        return ret
    
    def start(self, verbose = False):
        &#34;&#34;&#34;
        Executes the sequence, Step by Step according to Step configuration and logic
        &#34;&#34;&#34;

        if self.name not in [&#34;START&#34;, &#34;END&#34;]:
            print(&#34;\n&#34; + str(self.sim.timeline.model_time) + &#34;: *** Starting Sequence. Name: {}, number of Steps: {} ***&#34;.format(self.name, len(self.steps)))

        if self.check_inhibits():
            self.steps.sort()

            # Step 1 is the always the first step in a sequence.  Following steps dictated by Step property and logic.
            step = self.steps[0] 
            while True:
                if verbose:
                    print(str(self.sim.timeline.model_time) + &#34;: Executing step {}&#34;.format(step.number), end=&#34;...&#34;)                                
                step.execute_actions()
                if verbose:
                    print(str(self.sim.timeline.model_time) + &#34;: Executing {} action(s)&#34;.format(len(step.st)), end=&#34;...&#34;)
                start = self.sim.timeline.model_time
                while not step.check_trans():
                    time.sleep(1)
                    end = self.sim.timeline.model_time
                    if (end-start).seconds &gt; step.tmax:
                        message = str(self.sim.timeline.model_time) + &#34;: Sequence: {}, Step timeout in step {}.\n&#34;.format(self.name, step.number)
                        for trans in step.trans:
                            message += str(trans) +&#34;: &#34; + str(trans()) + &#34;\n&#34;
                        raise Exception(message)
                if verbose:
                    print(str(self.sim.timeline.model_time) + &#34;: Step {} executed successfully.&#34;.format(step.number))
                if step.next:
                    step = self.seqs[step.next()]
                else:
                    if self.name not in [&#34;START&#34;, &#34;END&#34;]:
                        print(str(self.sim.timeline.model_time) + &#34;: *** Sequence {} finished ***&#34;.format(self.name))
                    break
        else:
            raise Exception(&#34;Sequence cannot be started due to inhibit conditions&#34;)
        return self.name

    def add_step(self, step):
        self.steps.append(step)

    def add_steps(self, steps):
        for step in steps:
            self.add_step(step)</code></pre>
</details>
<div class="desc"><p>A sequence of steps to be executed in order, with optional inhibit conditions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the sequence.</dd>
<dt><strong><code>seqs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of all step objects (name  Step).</dd>
<dt><strong><code>sim</code></strong> :&ensp;<code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></dt>
<dd>Reference to the simulator object.</dd>
<dt><strong><code>inhibit_conditions</code></strong> :&ensp;<code>list</code> of <code>callables</code>, optional</dt>
<dd>Conditions that must evaluate False for the sequence to run.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, prints execution info.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Sequence.add_step"><code class="name flex">
<span>def <span class="ident">add_step</span></span>(<span>self, step)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_step(self, step):
    self.steps.append(step)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.Sequence.add_steps"><code class="name flex">
<span>def <span class="ident">add_steps</span></span>(<span>self, steps)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_steps(self, steps):
    for step in steps:
        self.add_step(step)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.Sequence.check_inhibits"><code class="name flex">
<span>def <span class="ident">check_inhibits</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_inhibits(self):
    &#34;&#34;&#34; Inhibit conditions must all evaluate to False to allow sequence to start&#34;&#34;&#34;
    ret = True
    if len(self.inhibits) &gt; 0:            
        for inhibit in self.inhibits:
            if inhibit():
                print(&#34;Inhibit condition prevents sequence start of &#34; + self.name + &#34;: &#34; + str(inhibit))
                ret = False
    return ret</code></pre>
</details>
<div class="desc"><p>Inhibit conditions must all evaluate to False to allow sequence to start</p></div>
</dd>
<dt id="YggSimLib.Sequence.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, verbose = False):
    &#34;&#34;&#34;
    Executes the sequence, Step by Step according to Step configuration and logic
    &#34;&#34;&#34;

    if self.name not in [&#34;START&#34;, &#34;END&#34;]:
        print(&#34;\n&#34; + str(self.sim.timeline.model_time) + &#34;: *** Starting Sequence. Name: {}, number of Steps: {} ***&#34;.format(self.name, len(self.steps)))

    if self.check_inhibits():
        self.steps.sort()

        # Step 1 is the always the first step in a sequence.  Following steps dictated by Step property and logic.
        step = self.steps[0] 
        while True:
            if verbose:
                print(str(self.sim.timeline.model_time) + &#34;: Executing step {}&#34;.format(step.number), end=&#34;...&#34;)                                
            step.execute_actions()
            if verbose:
                print(str(self.sim.timeline.model_time) + &#34;: Executing {} action(s)&#34;.format(len(step.st)), end=&#34;...&#34;)
            start = self.sim.timeline.model_time
            while not step.check_trans():
                time.sleep(1)
                end = self.sim.timeline.model_time
                if (end-start).seconds &gt; step.tmax:
                    message = str(self.sim.timeline.model_time) + &#34;: Sequence: {}, Step timeout in step {}.\n&#34;.format(self.name, step.number)
                    for trans in step.trans:
                        message += str(trans) +&#34;: &#34; + str(trans()) + &#34;\n&#34;
                    raise Exception(message)
            if verbose:
                print(str(self.sim.timeline.model_time) + &#34;: Step {} executed successfully.&#34;.format(step.number))
            if step.next:
                step = self.seqs[step.next()]
            else:
                if self.name not in [&#34;START&#34;, &#34;END&#34;]:
                    print(str(self.sim.timeline.model_time) + &#34;: *** Sequence {} finished ***&#34;.format(self.name))
                break
    else:
        raise Exception(&#34;Sequence cannot be started due to inhibit conditions&#34;)
    return self.name</code></pre>
</details>
<div class="desc"><p>Executes the sequence, Step by Step according to Step configuration and logic</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Step"><code class="flex name class">
<span>class <span class="ident">Step</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Step:
    &#34;&#34;&#34;
    A single step in a sequence.

    Args:
        config (dict): Configuration dictionary containing:
        number (int): Step number.
        actions (list of callables): Actions to perform when the step starts.
        transitions (list of callables): Conditions that must evaluate to True to complete the step.
        tmax (int): Maximum allowed simulator time (in seconds) for the step.
        next (Callable[[], str] or None): Function returning the key of the next step.
    &#34;&#34;&#34;
    def __init__(self, config):
        self.failed = False
        self.number = config[&#34;number&#34;]
        self.st = config[&#34;actions&#34;]
        self.trans = config[&#34;transitions&#34;]
        self.tmax = config[&#34;tmax&#34;]
        self.next = config[&#34;next&#34;]
  
    def execute_actions(self):
        &#34;&#34;&#34;
        Executes all actions
        &#34;&#34;&#34;
        for st in self.st:
            st()

    def check_trans(self):
        &#34;&#34;&#34;
        All transitions must evaluate to True to continue.
        &#34;&#34;&#34;
        ret = True
        for trans in self.trans:
            if not trans():
                ret = False
        return ret

    def StepAction(self):
        &#34;&#34;&#34;
        Returns the list of Step Actions
        &#34;&#34;&#34;
        return self.st

    def transition(self):
        &#34;&#34;&#34;
        Returns the list of Step Transitions
        &#34;&#34;&#34;
        return self.trans

    def onFail(self):
        &#34;&#34;&#34;
        To be implemented.  What to do on Step failure (conditions or transitions).  For now Exceptions are raised directly.
        &#34;&#34;&#34;
        return False

    def __lt__(self, other):
        &#34;&#34;&#34;
        To allow sorting
        &#34;&#34;&#34;
        return self.number &lt; other.number

    def __eq__(self, other):
        &#34;&#34;&#34;
        To allow sorting
        &#34;&#34;&#34;
        return self.number == other.number</code></pre>
</details>
<div class="desc"><p>A single step in a sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Configuration dictionary containing:</dd>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code></dt>
<dd>Step number.</dd>
<dt><strong><code>actions</code></strong> :&ensp;<code>list</code> of <code>callables</code></dt>
<dd>Actions to perform when the step starts.</dd>
<dt><strong><code>transitions</code></strong> :&ensp;<code>list</code> of <code>callables</code></dt>
<dd>Conditions that must evaluate to True to complete the step.</dd>
<dt><strong><code>tmax</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum allowed simulator time (in seconds) for the step.</dd>
<dt><strong><code>next</code></strong> :&ensp;<code>Callable[[], str]</code> or <code>None</code></dt>
<dd>Function returning the key of the next step.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Step.StepAction"><code class="name flex">
<span>def <span class="ident">StepAction</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StepAction(self):
    &#34;&#34;&#34;
    Returns the list of Step Actions
    &#34;&#34;&#34;
    return self.st</code></pre>
</details>
<div class="desc"><p>Returns the list of Step Actions</p></div>
</dd>
<dt id="YggSimLib.Step.check_trans"><code class="name flex">
<span>def <span class="ident">check_trans</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_trans(self):
    &#34;&#34;&#34;
    All transitions must evaluate to True to continue.
    &#34;&#34;&#34;
    ret = True
    for trans in self.trans:
        if not trans():
            ret = False
    return ret</code></pre>
</details>
<div class="desc"><p>All transitions must evaluate to True to continue.</p></div>
</dd>
<dt id="YggSimLib.Step.execute_actions"><code class="name flex">
<span>def <span class="ident">execute_actions</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_actions(self):
    &#34;&#34;&#34;
    Executes all actions
    &#34;&#34;&#34;
    for st in self.st:
        st()</code></pre>
</details>
<div class="desc"><p>Executes all actions</p></div>
</dd>
<dt id="YggSimLib.Step.onFail"><code class="name flex">
<span>def <span class="ident">onFail</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onFail(self):
    &#34;&#34;&#34;
    To be implemented.  What to do on Step failure (conditions or transitions).  For now Exceptions are raised directly.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
<div class="desc"><p>To be implemented.
What to do on Step failure (conditions or transitions).
For now Exceptions are raised directly.</p></div>
</dd>
<dt id="YggSimLib.Step.transition"><code class="name flex">
<span>def <span class="ident">transition</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transition(self):
    &#34;&#34;&#34;
    Returns the list of Step Transitions
    &#34;&#34;&#34;
    return self.trans</code></pre>
</details>
<div class="desc"><p>Returns the list of Step Transitions</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Transmitter"><code class="flex name class">
<span>class <span class="ident">Transmitter</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transmitter:
    &#34;&#34;&#34;
    Wrapper for reading transmitter values in the Yggdrasil Engineering Simulator.

    Args:
        tag (str): Tag name of the transmitter.
        model (YggLCS): Reference to the YggLCS simulation object.
        app (str, optional): Application name. Automatically inferred if not provided.
    &#34;&#34;&#34;
    def __init__(self, tag, model, app=False):  

        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.t = self.tl.get_block(app, tag)
            except:
                print(&#34;No transmitter with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No transmitter with tag {} found in any of the simulator applications&#34;.format(tag))
            self.t = False

        if self.t:
            if self.t.type not in [&#34;AlarmTransmitter&#34;]:
                print(&#34;Object is not a Transmitter. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.t.type))
                self.t = False

    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False   
    def get_value(self, unit):
        return self.tl.get_value(self.app, self.t.name + &#34;:MeasuredValue&#34;, unit=unit)</code></pre>
</details>
<div class="desc"><p>Wrapper for reading transmitter values in the Yggdrasil Engineering Simulator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code></dt>
<dd>Tag name of the transmitter.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></dt>
<dd>Reference to the YggLCS simulation object.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Application name. Automatically inferred if not provided.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Transmitter.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, unit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, unit):
    return self.tl.get_value(self.app, self.t.name + &#34;:MeasuredValue&#34;, unit=unit)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.YggLCS"><code class="flex name class">
<span>class <span class="ident">YggLCS</span></span>
<span>(</span><span>run=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YggLCS:
    &#34;&#34;&#34;
    Wrapper for initializing and managing a Yggdrasil Engineering Simulator project.

    Args:
        run (bool, optional): If True, starts the simulation immediately after loading.
    &#34;&#34;&#34;
    def __init__(self, run = False):

        root = Tk()
        root.withdraw()

        self.model = filedialog.askdirectory(**{&#34;title&#34;:&#34;Please select model directory&#34;})
        self.sim = kspice.Simulator(self.model)
        self.tl = _askTimeline(root, &#34;Timelines&#34;, self.sim.timelines).tl.get()
        self.timeline = self.sim.timelines[self.tl]
        self.timeline.activate()
        files = _askFiles(root, &#34;Files&#34;, self.timeline.models, self.timeline.parameters, self.timeline.initial_conditions)
        self.model = files.m.get()
        self.parameter = files.p.get()
        self.ic = files.i.get()
        self.timeline.load(self.timeline.models[self.model], self.timeline.parameters[self.parameter], self.timeline.initial_conditions[self.ic])
        self.timeline.initialize()
        if run:
            self.timeline.run()

    def get_timeline(self):
        &#34;&#34;&#34;
        Returns the active timeline object
        &#34;&#34;&#34;
        return self.timeline
    
    def on_off_valve(self, tag, app=False):
        &#34;&#34;&#34;
        Creates and returns a on-off valve object
        &#34;&#34;&#34;
        return On_Off_Valve(tag, self, app)

    def motor_heater(self, tag, app=False):
        &#34;&#34;&#34;
        Creates and returns an electrical element, used for heaters and motors
        &#34;&#34;&#34;
        return Motor_Heater(tag, self, app)

    def pid(self, tag, app=False):
        &#34;&#34;&#34;
        Creates and returns a PID controller
        &#34;&#34;&#34;
        return PID(tag, self, app)
    
    def choke(self, tag, app=False):
        &#34;&#34;&#34;        
        Creates and returns a choke object
        &#34;&#34;&#34;
        return Choke(tag, self, app)

    def transmitter(self, tag, app=False):
        &#34;&#34;&#34;
        Creates and returns an AlarmTransmitter object
        &#34;&#34;&#34;
        return Transmitter(tag, self, app)
    
    def run(self):
        self.timeline.run()
    def pause(self):
        self.timeline.pause()
    def close_project(self):
        self.sim.close_project()</code></pre>
</details>
<div class="desc"><p>Wrapper for initializing and managing a Yggdrasil Engineering Simulator project.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>run</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, starts the simulation immediately after loading.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.YggLCS.choke"><code class="name flex">
<span>def <span class="ident">choke</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choke(self, tag, app=False):
    &#34;&#34;&#34;        
    Creates and returns a choke object
    &#34;&#34;&#34;
    return Choke(tag, self, app)</code></pre>
</details>
<div class="desc"><p>Creates and returns a choke object</p></div>
</dd>
<dt id="YggSimLib.YggLCS.close_project"><code class="name flex">
<span>def <span class="ident">close_project</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_project(self):
    self.sim.close_project()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.YggLCS.get_timeline"><code class="name flex">
<span>def <span class="ident">get_timeline</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_timeline(self):
    &#34;&#34;&#34;
    Returns the active timeline object
    &#34;&#34;&#34;
    return self.timeline</code></pre>
</details>
<div class="desc"><p>Returns the active timeline object</p></div>
</dd>
<dt id="YggSimLib.YggLCS.motor_heater"><code class="name flex">
<span>def <span class="ident">motor_heater</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def motor_heater(self, tag, app=False):
    &#34;&#34;&#34;
    Creates and returns an electrical element, used for heaters and motors
    &#34;&#34;&#34;
    return Motor_Heater(tag, self, app)</code></pre>
</details>
<div class="desc"><p>Creates and returns an electrical element, used for heaters and motors</p></div>
</dd>
<dt id="YggSimLib.YggLCS.on_off_valve"><code class="name flex">
<span>def <span class="ident">on_off_valve</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_off_valve(self, tag, app=False):
    &#34;&#34;&#34;
    Creates and returns a on-off valve object
    &#34;&#34;&#34;
    return On_Off_Valve(tag, self, app)</code></pre>
</details>
<div class="desc"><p>Creates and returns a on-off valve object</p></div>
</dd>
<dt id="YggSimLib.YggLCS.pause"><code class="name flex">
<span>def <span class="ident">pause</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pause(self):
    self.timeline.pause()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.YggLCS.pid"><code class="name flex">
<span>def <span class="ident">pid</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pid(self, tag, app=False):
    &#34;&#34;&#34;
    Creates and returns a PID controller
    &#34;&#34;&#34;
    return PID(tag, self, app)</code></pre>
</details>
<div class="desc"><p>Creates and returns a PID controller</p></div>
</dd>
<dt id="YggSimLib.YggLCS.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    self.timeline.run()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.YggLCS.transmitter"><code class="name flex">
<span>def <span class="ident">transmitter</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transmitter(self, tag, app=False):
    &#34;&#34;&#34;
    Creates and returns an AlarmTransmitter object
    &#34;&#34;&#34;
    return Transmitter(tag, self, app)</code></pre>
</details>
<div class="desc"><p>Creates and returns an AlarmTransmitter object</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="YggSimLib.Admin" href="#YggSimLib.Admin">Admin</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Admin.execute_tasks" href="#YggSimLib.Admin.execute_tasks">execute_tasks</a></code></li>
<li><code><a title="YggSimLib.Admin.start" href="#YggSimLib.Admin.start">start</a></code></li>
<li><code><a title="YggSimLib.Admin.start_sequence" href="#YggSimLib.Admin.start_sequence">start_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Choke" href="#YggSimLib.Choke">Choke</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Choke.direct_control" href="#YggSimLib.Choke.direct_control">direct_control</a></code></li>
<li><code><a title="YggSimLib.Choke.get_pos" href="#YggSimLib.Choke.get_pos">get_pos</a></code></li>
<li><code><a title="YggSimLib.Choke.move_to" href="#YggSimLib.Choke.move_to">move_to</a></code></li>
<li><code><a title="YggSimLib.Choke.reset_control" href="#YggSimLib.Choke.reset_control">reset_control</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Motor_Heater" href="#YggSimLib.Motor_Heater">Motor_Heater</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Motor_Heater.is_off" href="#YggSimLib.Motor_Heater.is_off">is_off</a></code></li>
<li><code><a title="YggSimLib.Motor_Heater.is_on" href="#YggSimLib.Motor_Heater.is_on">is_on</a></code></li>
<li><code><a title="YggSimLib.Motor_Heater.start" href="#YggSimLib.Motor_Heater.start">start</a></code></li>
<li><code><a title="YggSimLib.Motor_Heater.stop" href="#YggSimLib.Motor_Heater.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.On_Off_Valve" href="#YggSimLib.On_Off_Valve">On_Off_Valve</a></code></h4>
<ul class="two-column">
<li><code><a title="YggSimLib.On_Off_Valve.close" href="#YggSimLib.On_Off_Valve.close">close</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.get_pos" href="#YggSimLib.On_Off_Valve.get_pos">get_pos</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.get_valve" href="#YggSimLib.On_Off_Valve.get_valve">get_valve</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.is_closed" href="#YggSimLib.On_Off_Valve.is_closed">is_closed</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.is_open" href="#YggSimLib.On_Off_Valve.is_open">is_open</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.open" href="#YggSimLib.On_Off_Valve.open">open</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.PID" href="#YggSimLib.PID">PID</a></code></h4>
<ul class="two-column">
<li><code><a title="YggSimLib.PID.get_mode" href="#YggSimLib.PID.get_mode">get_mode</a></code></li>
<li><code><a title="YggSimLib.PID.get_output" href="#YggSimLib.PID.get_output">get_output</a></code></li>
<li><code><a title="YggSimLib.PID.get_sp_selection" href="#YggSimLib.PID.get_sp_selection">get_sp_selection</a></code></li>
<li><code><a title="YggSimLib.PID.get_tracking" href="#YggSimLib.PID.get_tracking">get_tracking</a></code></li>
<li><code><a title="YggSimLib.PID.set_output" href="#YggSimLib.PID.set_output">set_output</a></code></li>
<li><code><a title="YggSimLib.PID.set_setpoint" href="#YggSimLib.PID.set_setpoint">set_setpoint</a></code></li>
<li><code><a title="YggSimLib.PID.set_tracking" href="#YggSimLib.PID.set_tracking">set_tracking</a></code></li>
<li><code><a title="YggSimLib.PID.set_tracking_value" href="#YggSimLib.PID.set_tracking_value">set_tracking_value</a></code></li>
<li><code><a title="YggSimLib.PID.to_auto" href="#YggSimLib.PID.to_auto">to_auto</a></code></li>
<li><code><a title="YggSimLib.PID.to_external" href="#YggSimLib.PID.to_external">to_external</a></code></li>
<li><code><a title="YggSimLib.PID.to_man" href="#YggSimLib.PID.to_man">to_man</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Sequence" href="#YggSimLib.Sequence">Sequence</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Sequence.add_step" href="#YggSimLib.Sequence.add_step">add_step</a></code></li>
<li><code><a title="YggSimLib.Sequence.add_steps" href="#YggSimLib.Sequence.add_steps">add_steps</a></code></li>
<li><code><a title="YggSimLib.Sequence.check_inhibits" href="#YggSimLib.Sequence.check_inhibits">check_inhibits</a></code></li>
<li><code><a title="YggSimLib.Sequence.start" href="#YggSimLib.Sequence.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Step" href="#YggSimLib.Step">Step</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Step.StepAction" href="#YggSimLib.Step.StepAction">StepAction</a></code></li>
<li><code><a title="YggSimLib.Step.check_trans" href="#YggSimLib.Step.check_trans">check_trans</a></code></li>
<li><code><a title="YggSimLib.Step.execute_actions" href="#YggSimLib.Step.execute_actions">execute_actions</a></code></li>
<li><code><a title="YggSimLib.Step.onFail" href="#YggSimLib.Step.onFail">onFail</a></code></li>
<li><code><a title="YggSimLib.Step.transition" href="#YggSimLib.Step.transition">transition</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Transmitter" href="#YggSimLib.Transmitter">Transmitter</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Transmitter.get_value" href="#YggSimLib.Transmitter.get_value">get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></h4>
<ul class="two-column">
<li><code><a title="YggSimLib.YggLCS.choke" href="#YggSimLib.YggLCS.choke">choke</a></code></li>
<li><code><a title="YggSimLib.YggLCS.close_project" href="#YggSimLib.YggLCS.close_project">close_project</a></code></li>
<li><code><a title="YggSimLib.YggLCS.get_timeline" href="#YggSimLib.YggLCS.get_timeline">get_timeline</a></code></li>
<li><code><a title="YggSimLib.YggLCS.motor_heater" href="#YggSimLib.YggLCS.motor_heater">motor_heater</a></code></li>
<li><code><a title="YggSimLib.YggLCS.on_off_valve" href="#YggSimLib.YggLCS.on_off_valve">on_off_valve</a></code></li>
<li><code><a title="YggSimLib.YggLCS.pause" href="#YggSimLib.YggLCS.pause">pause</a></code></li>
<li><code><a title="YggSimLib.YggLCS.pid" href="#YggSimLib.YggLCS.pid">pid</a></code></li>
<li><code><a title="YggSimLib.YggLCS.run" href="#YggSimLib.YggLCS.run">run</a></code></li>
<li><code><a title="YggSimLib.YggLCS.transmitter" href="#YggSimLib.YggLCS.transmitter">transmitter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
