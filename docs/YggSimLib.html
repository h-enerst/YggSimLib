<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>YggSimLib API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>YggSimLib</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="YggSimLib.Admin"><code class="flex name class">
<span>class <span class="ident">Admin</span></span>
<span>(</span><span>sequences, edges, glob, sim)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an Administration sequence.
</p>
<h2 id="arguments">Arguments</h2>
<p>sequences: A list of Sequence objects
edges: A list of tuples dictating the dependencies between sequences.
glob: a copy of the globals dictionary from calling module
sim: a reference to the YggLCS simulator object from calling module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Admin:

    &#34;&#34;&#34;
    Creates an Administration sequence.  
    Arguments:
        sequences: A list of Sequence objects
        edges: A list of tuples dictating the dependencies between sequences.
        glob: a copy of the globals dictionary from calling module
        sim: a reference to the YggLCS simulator object from calling module
    &#34;&#34;&#34;

    def __init__(self, sequences, edges, glob, sim):
        self.seq = {}
        for s in sequences:
            self.seq[s.name] = s
        # Initialise first step (START)
        start = Step({
            &#34;number&#34;: 1,
            &#34;conditions&#34;: [],
            &#34;actions&#34;: [],
            &#34;transitions&#34;: [],
            &#34;tmax&#34;: 2,
            &#34;next&#34;: None
        })
        start_seq = Sequence(&#34;START&#34;, 
               glob,
               sim,
               []
               )
        start_seq.add_step(start)
        self.seq[&#34;START&#34;] = start_seq

        #Initialize the last step (END)
        end = Sequence(&#34;END&#34;, 
               glob,
               sim,
               []
               )
        end.add_step(start)
        self.seq[&#34;END&#34;] = end
        
        self.edges = edges

        # Create a directed graph
        self.G = nx.DiGraph()
        # Create the nodes and connect the edges
        self.G.add_edges_from(edges)


    def start(self):
        &#34;&#34;&#34;
        Starts the admin sequence execution
        &#34;&#34;&#34;
        self.execute_tasks(self.G, self.seq)



    def start_sequence(self, seq, name):
        &#34;&#34;&#34;
        Helper function to start a sequence and return the name of the sequence that was started.
        &#34;&#34;&#34;
        seq.start()
        return name





# Execute the tasks based on the dependency graph
    def execute_tasks(self, graph, seq_objects):
        &#34;&#34;&#34;
        Function that starts all the sequences which has no parent or whos parent has completed. 
        Parallel sequences are started in separate pseudo threads to enable paralell execution. 
        Edges in directed graph dicated when a sequence can be started.
        &#34;&#34;&#34;
        # Find the start tasks (those that have no predecessors)
        initial_tasks = [n for n in graph.nodes if graph.in_degree(n) == 0]
    
        # Initialize an executor for parallel task execution
        with ThreadPoolExecutor() as executor:
            # Track futures
            task_futures = {}
    
            # Start initial tasks
            for task_name in initial_tasks:
                
                task_futures[task_name] = executor.submit(self.start_sequence, seq_objects[task_name], task_name)
    
            # As each task finishes, check if we can start dependent tasks
            while task_futures:
                for future in as_completed(task_futures.values()):
                    task_name = future.result()  # Get the result (task name)
                    
                    if task_name is None:
                        raise ValueError(&#34;Error: Task returned None!&#34;)
    
                    # Check if task has successors
                    if task_name in graph:
                        successors = list(graph.successors(task_name))
                        for successor in successors:
                            # Check if all predecessors of the successor have finished
                            predecessors = list(graph.predecessors(successor))
                            if all(p in task_futures and task_futures[p].done() for p in predecessors):
                                # Start successor task
                                
                                task_futures[successor] = executor.submit(self.start_sequence, seq_objects[successor], successor)
    
                    # Remove completed task from tracking
                    if task_name in task_futures:
                        del task_futures[task_name]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Admin.execute_tasks"><code class="name flex">
<span>def <span class="ident">execute_tasks</span></span>(<span>self, graph, seq_objects)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that starts all the sequences which has no parent or whos parent has completed.
Parallel sequences are started in separate pseudo threads to enable paralell execution.
Edges in directed graph dicated when a sequence can be started.</p></div>
</dd>
<dt id="YggSimLib.Admin.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the admin sequence execution</p></div>
</dd>
<dt id="YggSimLib.Admin.start_sequence"><code class="name flex">
<span>def <span class="ident">start_sequence</span></span>(<span>self, seq, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to start a sequence and return the name of the sequence that was started.</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Choke"><code class="flex name class">
<span>class <span class="ident">Choke</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for operating Choke objects in the Yggdrasil Engineering Simulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Choke:
    def __init__(self, tag, model, app=False):  
        &#34;&#34;&#34;Wrapper class for operating Choke objects in the Yggdrasil Engineering Simulator&#34;&#34;&#34;


        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.c = self.tl.get_block(app, tag)
            except:
                print(&#34;No choke with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No choke with tag {} found in any of the simulator applications&#34;.format(tag))
            self.c = False

        if self.c:
            if self.c.type not in [&#34;ControlValve&#34;, &#34;LedaValve&#34;]:
                print(&#34;Object is not a Control Valve. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.c.type))
                self.c = False

    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False       
    
    def move_to(self, pos):
        &#34;&#34;&#34;
        Wrapper that moves a choke object to a desired position.  
        If LocalControlSignalIn is connected from an external source, the choke will be set in Manual Mode
        &#34;&#34;&#34;
        connections = self.tl.get_block(self.app, self.c.name).input_connections
        if len(connections) &gt; 0:
            for conn in connections:
                if &#34;LocalControlSignalIn&#34; in str(conn):
                    self.direct_control()
        self.tl.set_value(self.app, self.c.name + &#34;:LocalControlSignalIn&#34;, pos, unit=&#34;%&#34;)
        self.tl.set_value(self.app, self.c.name + &#34;:TargetPosition&#34;, pos, unit=&#34;%&#34;)

    def direct_control(self):
        &#34;&#34;&#34;
        Set object in manual mode
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:InputSwitch&#34;,2)

    def reset_control(self):
        &#34;&#34;&#34;
        If object has defined connection to LocalControlSignalIn, set mode to Local
        &#34;&#34;&#34;
        connections = self.tl.get_block(self.app, self.c.name).input_connections
        if len(connections) &gt; 0:
            for conn in connections:
                if &#34;LocalControlSignalIn&#34; in str(conn):
                    self.tl.set_value(self.app, self.c.name + &#34;:InputSwitch&#34;, 0)      
    
    def get_pos(self):
        return self.tl.get_value(self.app, self.c.name + &#34;:ValveStemPosition&#34;, unit=&#34;%&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Choke.direct_control"><code class="name flex">
<span>def <span class="ident">direct_control</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set object in manual mode</p></div>
</dd>
<dt id="YggSimLib.Choke.get_pos"><code class="name flex">
<span>def <span class="ident">get_pos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.Choke.move_to"><code class="name flex">
<span>def <span class="ident">move_to</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper that moves a choke object to a desired position.<br>
If LocalControlSignalIn is connected from an external source, the choke will be set in Manual Mode</p></div>
</dd>
<dt id="YggSimLib.Choke.reset_control"><code class="name flex">
<span>def <span class="ident">reset_control</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If object has defined connection to LocalControlSignalIn, set mode to Local</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Motor_Heater"><code class="flex name class">
<span>class <span class="ident">Motor_Heater</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for operating motors and heaters in the Yggdrasil Engineering Simulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Motor_Heater:

    def __init__(self, tag, model, app=False):  
        &#34;&#34;&#34;Wrapper class for operating motors and heaters in the Yggdrasil Engineering Simulator&#34;&#34;&#34;


        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.m = self.tl.get_block(app, tag)
            except:
                print(&#34;No motor with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No motor with tag {} found in any of the simulator applications&#34;.format(tag))
            self.m = False

        if self.m:
            if self.m.type not in [&#34;ControlledAsynchronousMachine&#34;, &#34;ControlledElectricHeater&#34;]:
                print(&#34;Object is not a Motor or Heater. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.v.type))
                self.m = False

    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False       
    
    def start(self):
        
        &#34;&#34;&#34; Switch on the motor/element &#34;&#34;&#34;
        if self.m:
            self.tl.set_value(self.app, self.m.name + &#34;:LocalInput&#34;, True)
        else:
            print(&#34;Unvaild heater or motor object&#34;)   
    def stop(self):
        
        &#34;&#34;&#34; Switch off the motor/element &#34;&#34;&#34;
        if self.m:
            self.tl.set_value(self.app, self.m.name + &#34;:LocalInput&#34;, False)
        else:
            print(&#34;Unvaild heater or motor object&#34;)
    def is_on(self):
        &#34;&#34;&#34; Returns True if motor/element is switched on &#34;&#34;&#34;
        return self.tl.get_value(self.app, self.m.name + &#34;:LocalInput&#34;) == True
    def is_off(self):
        &#34;&#34;&#34; Returns True if motor/element is switched off &#34;&#34;&#34;
        return self.tl.get_value(self.app, self.m.name + &#34;:LocalInput&#34;) == False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Motor_Heater.is_off"><code class="name flex">
<span>def <span class="ident">is_off</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if motor/element is switched off</p></div>
</dd>
<dt id="YggSimLib.Motor_Heater.is_on"><code class="name flex">
<span>def <span class="ident">is_on</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if motor/element is switched on</p></div>
</dd>
<dt id="YggSimLib.Motor_Heater.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Switch on the motor/element</p></div>
</dd>
<dt id="YggSimLib.Motor_Heater.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Switch off the motor/element</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.On_Off_Valve"><code class="flex name class">
<span>class <span class="ident">On_Off_Valve</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for operating block-valves and motor-operated-valves in the Yggdrasil Engineering Simulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class On_Off_Valve:
    
    def __init__(self, tag, model, app=False):  
        &#34;&#34;&#34;Wrapper class for operating block-valves and motor-operated-valves in the Yggdrasil Engineering Simulator&#34;&#34;&#34;


        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.v = self.tl.get_block(app, tag)
            except:
                print(&#34;No valve with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No valve with tag {} found in any of the simulator applications&#34;.format(tag))
            self.v = False

        if self.v:
            if self.v.type not in [&#34;MotorOperatedValve&#34;, &#34;BlockValve&#34;, &#34;LedaValve&#34;]:
                print(&#34;Object is not a Leda-Valve, Motor-Operated_Valve or Block-Valve. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.v.type))
                self.v = False
    
    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False    
    
    def get_valve(self):
        &#34;&#34;&#34; Return the BlockValve object &#34;&#34;&#34;
        return self.v
    

    def close(self):    
        &#34;&#34;&#34; Wrapper that closes the valve regardless of type &#34;&#34;&#34;
        if self.v:
            if self.v.type == &#34;MotorOperatedValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalClose&#34;, True)
            elif self.v.type == &#34;BlockValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalInput&#34;, False)
            elif self.v.type == &#34;LedaValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalControlSignalIn&#34;, 0, unit=&#34;%&#34;)
        else:
            print(&#34;Unvaild valve object&#34;)

    def open(self):
        &#34;&#34;&#34; Wrapper that open the valve regardless of type &#34;&#34;&#34;
        if self.v:
            if self.v.type == &#34;MotorOperatedValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalOpen&#34;, True)
            elif self.v.type == &#34;BlockValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalInput&#34;, True)
            elif self.v.type == &#34;LedaValve&#34;:
                self.tl.set_value(self.app, self.v.name + &#34;:LocalControlSignalIn&#34;, 100, unit=&#34;%&#34;)
        else:
            print(&#34;Unvaild valve object&#34;)
            
    def get_pos(self):
        &#34;&#34;&#34; Wrapper that returns the stem position of the valve in percentage &#34;&#34;&#34;
        if self.v:
            return self.tl.get_value(self.app, self.v.name + &#34;:ValveStemPosition&#34;, unit=&#34;%&#34;)
        else:
            print(&#34;Unvaild valve object&#34;)
            
    def is_open(self):
        &#34;&#34;&#34; Wrapper that returns True if valve is defined as open &#34;&#34;&#34;
        if self.v:
            return self.tl.get_value(self.app, self.v.name + &#34;:IsDefinedOpen&#34;)
        else:
            print(&#34;Unvaild valve object&#34;)
            
    def is_closed(self):
        &#34;&#34;&#34; Wrapper that returns True if valve is defined as closed &#34;&#34;&#34;
        if self.v:
            return self.tl.get_value(self.app, self.v.name + &#34;:IsDefinedClosed&#34;)
        else:
            print(&#34;Unvaild valve object&#34;)        </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.On_Off_Valve.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper that closes the valve regardless of type</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.get_pos"><code class="name flex">
<span>def <span class="ident">get_pos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper that returns the stem position of the valve in percentage</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.get_valve"><code class="name flex">
<span>def <span class="ident">get_valve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the BlockValve object</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper that returns True if valve is defined as closed</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.is_open"><code class="name flex">
<span>def <span class="ident">is_open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper that returns True if valve is defined as open</p></div>
</dd>
<dt id="YggSimLib.On_Off_Valve.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper that open the valve regardless of type</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.PID"><code class="flex name class">
<span>class <span class="ident">PID</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for operating PID controllers in the Yggdrasil Engineering Simulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PID:
    def __init__(self, tag, model, app=False):  
        &#34;&#34;&#34;Wrapper class for operating PID controllers in the Yggdrasil Engineering Simulator&#34;&#34;&#34;


        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.c = self.tl.get_block(app, tag)
            except:
                print(&#34;No PID controller with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No PID controller with tag {} found in any of the simulator applications&#34;.format(tag))
            self.c = False

        if self.c:
            if self.c.type not in [&#34;PidController&#34;]:
                print(&#34;Object is not a PID Controller. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.v.type))
                self.c = False

    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False   
    
    def get_mode(self):
        &#34;&#34;&#34;
        Returns text representation of the current mode
        &#34;&#34;&#34;
        m = self.tl.get_value(self.app, self.c.name + &#34;:Mode&#34;)
        if m == 0:
            return (&#34;Auto&#34;)
        elif m == 1:
            return (&#34;Manual&#34;)
        else: 
            return(&#34;External&#34;)
    
    def get_sp_selection(self):
        s = self.tl.get_value(self.app, self.c.name + &#34;:SetpointSelection&#34;)
        if s == 0:
            return(&#34;Internal&#34;)
        else:
            return(&#34;External&#34;)

    def to_auto(self):
        &#34;&#34;&#34;
        Set controller mode to Auto
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 0)

    def to_man(self):
        &#34;&#34;&#34;
        Set controller mode to Manual
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 1)

    def to_external(self):
        &#34;&#34;&#34;
        Set controller mode to External SP
        &#34;&#34;&#34;
        self.tl.set_value(self.app, self.c.name + &#34;:Mode&#34;, 2)        

    def set_output(self, out):
        &#34;&#34;&#34;
        Change output of controller if controller is in manual mode
        &#34;&#34;&#34;
        if self.get_mode() == &#34;Manual&#34;:
            self.tl.set_value(self.app, self.c.name + &#34;:ControllerOutput&#34;, out)
    def get_output(self):
        &#34;&#34;&#34;
        Get output of controller
        &#34;&#34;&#34;        
        return self.tl.get_value(self.app, self.c.name + &#34;:ControllerOutput&#34;)

    def set_setpoint(self, sp):
        &#34;&#34;&#34;
        Change internal setpoint of controller if controller is in manual or auto with internal setpoint selection
        &#34;&#34;&#34;
        if self.get_mode() == &#34;Manual&#34; or (self.get_mode() == &#34;Auto&#34; and self.get_sp_selection() == &#34;Internal&#34;):
            self.tl.set_value(self.app, self.c.name + &#34;:InternalSetpoint&#34;, sp)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.PID.get_mode"><code class="name flex">
<span>def <span class="ident">get_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns text representation of the current mode</p></div>
</dd>
<dt id="YggSimLib.PID.get_output"><code class="name flex">
<span>def <span class="ident">get_output</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get output of controller</p></div>
</dd>
<dt id="YggSimLib.PID.get_sp_selection"><code class="name flex">
<span>def <span class="ident">get_sp_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.PID.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, out)</span>
</code></dt>
<dd>
<div class="desc"><p>Change output of controller if controller is in manual mode</p></div>
</dd>
<dt id="YggSimLib.PID.set_setpoint"><code class="name flex">
<span>def <span class="ident">set_setpoint</span></span>(<span>self, sp)</span>
</code></dt>
<dd>
<div class="desc"><p>Change internal setpoint of controller if controller is in manual or auto with internal setpoint selection</p></div>
</dd>
<dt id="YggSimLib.PID.to_auto"><code class="name flex">
<span>def <span class="ident">to_auto</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set controller mode to Auto</p></div>
</dd>
<dt id="YggSimLib.PID.to_external"><code class="name flex">
<span>def <span class="ident">to_external</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set controller mode to External SP</p></div>
</dd>
<dt id="YggSimLib.PID.to_man"><code class="name flex">
<span>def <span class="ident">to_man</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set controller mode to Manual</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Sequence"><code class="flex name class">
<span>class <span class="ident">Sequence</span></span>
<span>(</span><span>name, glob, sim, inhibit_conditions=[], verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sequencer object.
Consists of a collection of Step objects.
Constructor requires the globals() dictionary from calling module as second argument.<br>
Optional inhibit conditions is a list with conditions in the form of function references.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sequence:
    &#34;&#34;&#34;
    Sequencer object.  Consists of a collection of Step objects.
    Constructor requires the globals() dictionary from calling module as second argument.  
    Optional inhibit conditions is a list with conditions in the form of function references.
    &#34;&#34;&#34;

    def __init__(self, name, glob, sim, inhibit_conditions=[], verbose = False):
        self.glob = glob
        self.steps = []
        self.inhibits = inhibit_conditions
        self.name = name
        self.sim = sim
        self.verbose = verbose

    def check_inhibits(self):
        &#34;&#34;&#34; Inhibit conditions must all evaluate to False to allow sequence to start&#34;&#34;&#34;
        ret = True
        if len(self.inhibits) &gt; 0:            
            for inhibit in self.inhibits:
                if inhibit():
                    print(&#34;Inhibit condition prevents sequence start of &#34; + self.name + &#34;: &#34; + str(inhibit))
                    ret = False
        return ret
    
    def start(self):
        &#34;&#34;&#34;
        Executes the sequence, Step by Step according to Step configuration and logic
        &#34;&#34;&#34;

        print(&#34;\n*** Starting Sequence. Name: {}, number of Steps: {} ***&#34;.format(self.name, len(self.steps)))

        if self.check_inhibits():
            self.steps.sort()

            # Step 1 is the always the first step in a sequence.  Following steps dictated by Step property and logic.
            step = self.steps[0] 
            while True:
                if self.verbose:
                    print(&#34;Executing step {}&#34;.format(step.number), end=&#34;...&#34;) 
                if step.check_conditions():
                    #print(&#34;Conditions all ok&#34;, end=&#34;...&#34;)                
                    step.execute_actions()
                    if self.verbose:
                        print(&#34;Executing {} action(s)&#34;.format(len(step.st)), end=&#34;...&#34;)
                    start = self.sim.timeline.model_time
                    while not step.check_trans():
                        time.sleep(1)
                        end = self.sim.timeline.model_time
                        if (end-start).seconds &gt; step.tmax:
                            raise Exception(&#34;Step timeout in step number {}&#34;.format(step.number))
                if self.verbose:
                    print(&#34;Step {} executed successfully.&#34;.format(step.number))
                if step.next:
                    step = self.glob[step.next()]
                else:
                    print(&#34;*** Sequence {} finished ***&#34;.format(self.name))
                    break
        else:
            raise Exception(&#34;Sequence cannot be started due to inhibit conditions&#34;)
        return self.name

    def add_step(self, step):
        self.steps.append(step)

    def add_steps(self, steps):
        for step in steps:
            self.add_step(step)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Sequence.add_step"><code class="name flex">
<span>def <span class="ident">add_step</span></span>(<span>self, step)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.Sequence.add_steps"><code class="name flex">
<span>def <span class="ident">add_steps</span></span>(<span>self, steps)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.Sequence.check_inhibits"><code class="name flex">
<span>def <span class="ident">check_inhibits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Inhibit conditions must all evaluate to False to allow sequence to start</p></div>
</dd>
<dt id="YggSimLib.Sequence.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes the sequence, Step by Step according to Step configuration and logic</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Step"><code class="flex name class">
<span>class <span class="ident">Step</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>A Sequence Step object.
Constructor takes Step configuration in the form of a dictionary.<br>
Required fields in dictionary:
number: The step number.
conditions: A list of conditions in the form of function references, all must be evaluated to True for the step to execute
actions: A list of actions in the form of function references, all will be executed simultaniously
transitions: A list of transition conditions in the form of function references.
All must be evaluated to True for the step to finish.
tmax: The maximum number of seconds the step can take, measured in simulator time.
next: The name of the next Step variable in string format.
Will be evaluated in runtime to find the correct object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Step:
    &#34;&#34;&#34;
    A Sequence Step object.  Constructor takes Step configuration in the form of a dictionary.  
    Required fields in dictionary:
        number: The step number. 
        conditions: A list of conditions in the form of function references, all must be evaluated to True for the step to execute
        actions: A list of actions in the form of function references, all will be executed simultaniously
        transitions: A list of transition conditions in the form of function references.  All must be evaluated to True for the step to finish.
        tmax: The maximum number of seconds the step can take, measured in simulator time.
        next: The name of the next Step variable in string format.  Will be evaluated in runtime to find the correct object.
    &#34;&#34;&#34;
    def __init__(self, config):
        self.failed = False
        self.number = config[&#34;number&#34;]
        self.cond = config[&#34;conditions&#34;]
        self.st = config[&#34;actions&#34;]
        self.trans = config[&#34;transitions&#34;]
        self.tmax = config[&#34;tmax&#34;]
        self.next = config[&#34;next&#34;]

    def conditions(self):
        &#34;&#34;&#34;
        Returns the list of condition function references
        &#34;&#34;&#34;
        return self.cond

    def check_conditions(self):
        &#34;&#34;&#34;
        All conditions must evaluate to True to continue
        &#34;&#34;&#34;
        for cond in self.cond:
            
            if not cond():
                raise Exception(&#34;Condition not met: &#34; + str(cond))
                return False
        return True
    def execute_actions(self):
        &#34;&#34;&#34;
        Executes all actions
        &#34;&#34;&#34;
        for st in self.st:
            st()

    def check_trans(self):
        &#34;&#34;&#34;
        All transitions must evaluate to True to continue.
        &#34;&#34;&#34;
        ret = True
        for trans in self.trans:
            if not trans():
                ret = False
        return ret

    def StepAction(self):
        &#34;&#34;&#34;
        Returns the list of Step Actions
        &#34;&#34;&#34;
        return self.st

    def transition(self):
        &#34;&#34;&#34;
        Returns the list of Step Transitions
        &#34;&#34;&#34;
        return self.trans

    def onFail(self):
        &#34;&#34;&#34;
        To be implemented.  What to do on Step failure (conditions or transitions).  For now Exceptions are raised directly.
        &#34;&#34;&#34;
        return False

    def __lt__(self, other):
        &#34;&#34;&#34;
        To allow sorting
        &#34;&#34;&#34;
        return self.number &lt; other.number

    def __eq__(self, other):
        &#34;&#34;&#34;
        To allow sorting
        &#34;&#34;&#34;
        return self.number == other.number</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Step.StepAction"><code class="name flex">
<span>def <span class="ident">StepAction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of Step Actions</p></div>
</dd>
<dt id="YggSimLib.Step.check_conditions"><code class="name flex">
<span>def <span class="ident">check_conditions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>All conditions must evaluate to True to continue</p></div>
</dd>
<dt id="YggSimLib.Step.check_trans"><code class="name flex">
<span>def <span class="ident">check_trans</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>All transitions must evaluate to True to continue.</p></div>
</dd>
<dt id="YggSimLib.Step.conditions"><code class="name flex">
<span>def <span class="ident">conditions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of condition function references</p></div>
</dd>
<dt id="YggSimLib.Step.execute_actions"><code class="name flex">
<span>def <span class="ident">execute_actions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes all actions</p></div>
</dd>
<dt id="YggSimLib.Step.onFail"><code class="name flex">
<span>def <span class="ident">onFail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>To be implemented.
What to do on Step failure (conditions or transitions).
For now Exceptions are raised directly.</p></div>
</dd>
<dt id="YggSimLib.Step.transition"><code class="name flex">
<span>def <span class="ident">transition</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of Step Transitions</p></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.Transmitter"><code class="flex name class">
<span>class <span class="ident">Transmitter</span></span>
<span>(</span><span>tag, model, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for reading transmitter objects in the Yggdrasil Engineering Simulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transmitter:
    def __init__(self, tag, model, app=False):  
        &#34;&#34;&#34;Wrapper class for reading transmitter objects in the Yggdrasil Engineering Simulator&#34;&#34;&#34;


        self.sim = model.sim
        self.tl = model.timeline
        
        if not app:

            applications = [x.name for x in self.tl.applications]
            
            if tag[0] in &#34;DEFNS&#34;:
                app = &#34;HuginA&#34; if &#34;HuginA&#34; in applications else self._search_application_(tag)
            
            elif tag[0] in &#34;ACVWYZ&#34;:
                app = &#34;Munin&#34; if &#34;Munin&#34; in applications else self._search_application_(tag)

            elif tag[0] in &#34;G&#34;:
                app = &#34;HuginB&#34; if &#34;HuginB&#34; in applications else self._search_application_(tag)
            else:
                app = self._search_application_(tag)
        

        self.app = app
        
        if self.app:
            try:
                self.t = self.tl.get_block(app, tag)
            except:
                print(&#34;No transmitter with tag {} found in application {}&#34;.format(tag, self.app))
        else:
            print(&#34;No transmitter with tag {} found in any of the simulator applications&#34;.format(tag))
            self.t = False

        if self.t:
            if self.t.type not in [&#34;AlarmTransmitter&#34;]:
                print(&#34;Object is not a Transmitter. Object is of type {}.\nNo further operations on object allowed.&#34;.format(self.t.type))
                self.t = False

    def _search_application_(self, tag):
        &#34;&#34;&#34; Returns the application name where tag can be found &#34;&#34;&#34;
        for application in self.tl.applications:
            try:
                temp = self.tl.get_block(application.name, tag)
                print(&#34;{} found in application {}&#34;.format(tag, application.name))
                return application.name
                
            except:
                return False   
    def get_value(self, unit):
        return self.tl.get_value(self.app, self.t.name + &#34;:MeasuredValue&#34;, unit=unit)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.Transmitter.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, unit)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="YggSimLib.YggLCS"><code class="flex name class">
<span>class <span class="ident">YggLCS</span></span>
<span>(</span><span>run=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for creating a simulator object.<br>
Will invoke GUI elements for choosing model, timeline and timeline-files.</p>
<p>Initialise a Yggdrasil LCS object.<br>
Optional "run" parameter will call "run" on timeline after initialization if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YggLCS:
    &#34;&#34;&#34;
    Wrapper for creating a simulator object.  
    Will invoke GUI elements for choosing model, timeline and timeline-files.
    &#34;&#34;&#34;
    def __init__(self, run = False):
        &#34;&#34;&#34;
        Initialise a Yggdrasil LCS object.  
        Optional &#34;run&#34; parameter will call &#34;run&#34; on timeline after initialization if True
        &#34;&#34;&#34;

        root = Tk()
        root.withdraw()

        self.model = filedialog.askdirectory(**{&#34;title&#34;:&#34;Please select model directory&#34;})
        self.sim = kspice.Simulator(self.model)
        self.tl = _askTimeline(root, &#34;Timelines&#34;, self.sim.timelines).tl.get()
        self.timeline = self.sim.timelines[self.tl]
        self.timeline.activate()
        files = _askFiles(root, &#34;Files&#34;, self.timeline.models, self.timeline.parameters, self.timeline.initial_conditions)
        self.model = files.m.get()
        self.parameter = files.p.get()
        self.ic = files.i.get()
        self.timeline.load(self.timeline.models[self.model], self.timeline.parameters[self.parameter], self.timeline.initial_conditions[self.ic])
        self.timeline.initialize()
        if run:
            self.timeline.run()

    def get_timeline(self):
        &#34;&#34;&#34;
        Returns the active timeline object
        &#34;&#34;&#34;
        return self.timeline
    
    def on_off_valve(self, tag, app=False):
        &#34;&#34;&#34;
        Creates and returns a on-off valve object
        &#34;&#34;&#34;
        return On_Off_Valve(tag, self, app)

    def motor_heater(self, tag, app=False):
        &#34;&#34;&#34;
        Creates and returns an electrical element, used for heaters and motors
        &#34;&#34;&#34;
        return Motor_Heater(tag, self, app)

    def pid(self, tag, app=False):
        &#34;&#34;&#34;
        Creates and returns a PID controller
        &#34;&#34;&#34;
        return PID(tag, self, app)
    
    def choke(self, tag, app=False):
        &#34;&#34;&#34;        
        Creates and returns a choke object
        &#34;&#34;&#34;
        return Choke(tag, self, app)

    def transmitter(self, tag, app=False):
        &#34;&#34;&#34;
        Creates and returns an AlarmTransmitter object
        &#34;&#34;&#34;
        return Transmitter(tag, self, app)
    
    def run(self):
        self.timeline.run()
    def pause(self):
        self.timeline.pause()
    def close_project(self):
        self.sim.close_project()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="YggSimLib.YggLCS.choke"><code class="name flex">
<span>def <span class="ident">choke</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a choke object</p></div>
</dd>
<dt id="YggSimLib.YggLCS.close_project"><code class="name flex">
<span>def <span class="ident">close_project</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.YggLCS.get_timeline"><code class="name flex">
<span>def <span class="ident">get_timeline</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the active timeline object</p></div>
</dd>
<dt id="YggSimLib.YggLCS.motor_heater"><code class="name flex">
<span>def <span class="ident">motor_heater</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns an electrical element, used for heaters and motors</p></div>
</dd>
<dt id="YggSimLib.YggLCS.on_off_valve"><code class="name flex">
<span>def <span class="ident">on_off_valve</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a on-off valve object</p></div>
</dd>
<dt id="YggSimLib.YggLCS.pause"><code class="name flex">
<span>def <span class="ident">pause</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.YggLCS.pid"><code class="name flex">
<span>def <span class="ident">pid</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a PID controller</p></div>
</dd>
<dt id="YggSimLib.YggLCS.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="YggSimLib.YggLCS.transmitter"><code class="name flex">
<span>def <span class="ident">transmitter</span></span>(<span>self, tag, app=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns an AlarmTransmitter object</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="YggSimLib.Admin" href="#YggSimLib.Admin">Admin</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Admin.execute_tasks" href="#YggSimLib.Admin.execute_tasks">execute_tasks</a></code></li>
<li><code><a title="YggSimLib.Admin.start" href="#YggSimLib.Admin.start">start</a></code></li>
<li><code><a title="YggSimLib.Admin.start_sequence" href="#YggSimLib.Admin.start_sequence">start_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Choke" href="#YggSimLib.Choke">Choke</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Choke.direct_control" href="#YggSimLib.Choke.direct_control">direct_control</a></code></li>
<li><code><a title="YggSimLib.Choke.get_pos" href="#YggSimLib.Choke.get_pos">get_pos</a></code></li>
<li><code><a title="YggSimLib.Choke.move_to" href="#YggSimLib.Choke.move_to">move_to</a></code></li>
<li><code><a title="YggSimLib.Choke.reset_control" href="#YggSimLib.Choke.reset_control">reset_control</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Motor_Heater" href="#YggSimLib.Motor_Heater">Motor_Heater</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Motor_Heater.is_off" href="#YggSimLib.Motor_Heater.is_off">is_off</a></code></li>
<li><code><a title="YggSimLib.Motor_Heater.is_on" href="#YggSimLib.Motor_Heater.is_on">is_on</a></code></li>
<li><code><a title="YggSimLib.Motor_Heater.start" href="#YggSimLib.Motor_Heater.start">start</a></code></li>
<li><code><a title="YggSimLib.Motor_Heater.stop" href="#YggSimLib.Motor_Heater.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.On_Off_Valve" href="#YggSimLib.On_Off_Valve">On_Off_Valve</a></code></h4>
<ul class="two-column">
<li><code><a title="YggSimLib.On_Off_Valve.close" href="#YggSimLib.On_Off_Valve.close">close</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.get_pos" href="#YggSimLib.On_Off_Valve.get_pos">get_pos</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.get_valve" href="#YggSimLib.On_Off_Valve.get_valve">get_valve</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.is_closed" href="#YggSimLib.On_Off_Valve.is_closed">is_closed</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.is_open" href="#YggSimLib.On_Off_Valve.is_open">is_open</a></code></li>
<li><code><a title="YggSimLib.On_Off_Valve.open" href="#YggSimLib.On_Off_Valve.open">open</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.PID" href="#YggSimLib.PID">PID</a></code></h4>
<ul class="two-column">
<li><code><a title="YggSimLib.PID.get_mode" href="#YggSimLib.PID.get_mode">get_mode</a></code></li>
<li><code><a title="YggSimLib.PID.get_output" href="#YggSimLib.PID.get_output">get_output</a></code></li>
<li><code><a title="YggSimLib.PID.get_sp_selection" href="#YggSimLib.PID.get_sp_selection">get_sp_selection</a></code></li>
<li><code><a title="YggSimLib.PID.set_output" href="#YggSimLib.PID.set_output">set_output</a></code></li>
<li><code><a title="YggSimLib.PID.set_setpoint" href="#YggSimLib.PID.set_setpoint">set_setpoint</a></code></li>
<li><code><a title="YggSimLib.PID.to_auto" href="#YggSimLib.PID.to_auto">to_auto</a></code></li>
<li><code><a title="YggSimLib.PID.to_external" href="#YggSimLib.PID.to_external">to_external</a></code></li>
<li><code><a title="YggSimLib.PID.to_man" href="#YggSimLib.PID.to_man">to_man</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Sequence" href="#YggSimLib.Sequence">Sequence</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Sequence.add_step" href="#YggSimLib.Sequence.add_step">add_step</a></code></li>
<li><code><a title="YggSimLib.Sequence.add_steps" href="#YggSimLib.Sequence.add_steps">add_steps</a></code></li>
<li><code><a title="YggSimLib.Sequence.check_inhibits" href="#YggSimLib.Sequence.check_inhibits">check_inhibits</a></code></li>
<li><code><a title="YggSimLib.Sequence.start" href="#YggSimLib.Sequence.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Step" href="#YggSimLib.Step">Step</a></code></h4>
<ul class="two-column">
<li><code><a title="YggSimLib.Step.StepAction" href="#YggSimLib.Step.StepAction">StepAction</a></code></li>
<li><code><a title="YggSimLib.Step.check_conditions" href="#YggSimLib.Step.check_conditions">check_conditions</a></code></li>
<li><code><a title="YggSimLib.Step.check_trans" href="#YggSimLib.Step.check_trans">check_trans</a></code></li>
<li><code><a title="YggSimLib.Step.conditions" href="#YggSimLib.Step.conditions">conditions</a></code></li>
<li><code><a title="YggSimLib.Step.execute_actions" href="#YggSimLib.Step.execute_actions">execute_actions</a></code></li>
<li><code><a title="YggSimLib.Step.onFail" href="#YggSimLib.Step.onFail">onFail</a></code></li>
<li><code><a title="YggSimLib.Step.transition" href="#YggSimLib.Step.transition">transition</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.Transmitter" href="#YggSimLib.Transmitter">Transmitter</a></code></h4>
<ul class="">
<li><code><a title="YggSimLib.Transmitter.get_value" href="#YggSimLib.Transmitter.get_value">get_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="YggSimLib.YggLCS" href="#YggSimLib.YggLCS">YggLCS</a></code></h4>
<ul class="two-column">
<li><code><a title="YggSimLib.YggLCS.choke" href="#YggSimLib.YggLCS.choke">choke</a></code></li>
<li><code><a title="YggSimLib.YggLCS.close_project" href="#YggSimLib.YggLCS.close_project">close_project</a></code></li>
<li><code><a title="YggSimLib.YggLCS.get_timeline" href="#YggSimLib.YggLCS.get_timeline">get_timeline</a></code></li>
<li><code><a title="YggSimLib.YggLCS.motor_heater" href="#YggSimLib.YggLCS.motor_heater">motor_heater</a></code></li>
<li><code><a title="YggSimLib.YggLCS.on_off_valve" href="#YggSimLib.YggLCS.on_off_valve">on_off_valve</a></code></li>
<li><code><a title="YggSimLib.YggLCS.pause" href="#YggSimLib.YggLCS.pause">pause</a></code></li>
<li><code><a title="YggSimLib.YggLCS.pid" href="#YggSimLib.YggLCS.pid">pid</a></code></li>
<li><code><a title="YggSimLib.YggLCS.run" href="#YggSimLib.YggLCS.run">run</a></code></li>
<li><code><a title="YggSimLib.YggLCS.transmitter" href="#YggSimLib.YggLCS.transmitter">transmitter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
